// Generated by gencpp from file mission_parse/formationwithtask.msg
// DO NOT EDIT!

#ifndef MISSION_PARSE_MESSAGE_FORMATIONWITHTASK_H
#define MISSION_PARSE_MESSAGE_FORMATIONWITHTASK_H

#include <map>
#include <string>
#include <vector>

#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>
#include <ros/serialization.h>
#include <ros/types.h>

#include <geometry_msgs/Pose.h>
#include <std_msgs/Header.h>

namespace mission_parse {
template <class ContainerAllocator>
struct formationwithtask_ {
    typedef formationwithtask_<ContainerAllocator> Type;

    formationwithtask_()
        : header()
        , goal()
        , leader_id(0)
        , follower_num(0)
        , follower_id()
        , distance()
        , angle()
    {
    }
    formationwithtask_(const ContainerAllocator& _alloc)
        : header(_alloc)
        , goal(_alloc)
        , leader_id(0)
        , follower_num(0)
        , follower_id(_alloc)
        , distance(_alloc)
        , angle(_alloc)
    {
        (void)_alloc;
    }

    typedef ::std_msgs::Header_<ContainerAllocator> _header_type;
    _header_type header;

    typedef ::geometry_msgs::Pose_<ContainerAllocator> _goal_type;
    _goal_type goal;

    typedef int16_t _leader_id_type;
    _leader_id_type leader_id;

    typedef int16_t _follower_num_type;
    _follower_num_type follower_num;

    typedef std::vector<int16_t, typename ContainerAllocator::template rebind<int16_t>::other> _follower_id_type;
    _follower_id_type follower_id;

    typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other> _distance_type;
    _distance_type distance;

    typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other> _angle_type;
    _angle_type angle;

    typedef boost::shared_ptr<::mission_parse::formationwithtask_<ContainerAllocator>> Ptr;
    typedef boost::shared_ptr<::mission_parse::formationwithtask_<ContainerAllocator> const> ConstPtr;

}; // struct formationwithtask_

typedef ::mission_parse::formationwithtask_<std::allocator<void>> formationwithtask;

typedef boost::shared_ptr<::mission_parse::formationwithtask> formationwithtaskPtr;
typedef boost::shared_ptr<::mission_parse::formationwithtask const> formationwithtaskConstPtr;

// constants requiring out of line definition

template <typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mission_parse::formationwithtask_<ContainerAllocator>& v)
{
    ros::message_operations::Printer<::mission_parse::formationwithtask_<ContainerAllocator>>::stream(s, "", v);
    return s;
}

template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mission_parse::formationwithtask_<ContainerAllocator1>& lhs, const ::mission_parse::formationwithtask_<ContainerAllocator2>& rhs)
{
    return lhs.header == rhs.header && lhs.goal == rhs.goal && lhs.leader_id == rhs.leader_id && lhs.follower_num == rhs.follower_num && lhs.follower_id == rhs.follower_id && lhs.distance == rhs.distance && lhs.angle == rhs.angle;
}

template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mission_parse::formationwithtask_<ContainerAllocator1>& lhs, const ::mission_parse::formationwithtask_<ContainerAllocator2>& rhs)
{
    return !(lhs == rhs);
}

} // namespace mission_parse

namespace ros {
namespace message_traits {

    template <class ContainerAllocator>
    struct IsFixedSize<::mission_parse::formationwithtask_<ContainerAllocator>>
        : FalseType {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<::mission_parse::formationwithtask_<ContainerAllocator> const>
        : FalseType {
    };

    template <class ContainerAllocator>
    struct IsMessage<::mission_parse::formationwithtask_<ContainerAllocator>>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct IsMessage<::mission_parse::formationwithtask_<ContainerAllocator> const>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct HasHeader<::mission_parse::formationwithtask_<ContainerAllocator>>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct HasHeader<::mission_parse::formationwithtask_<ContainerAllocator> const>
        : TrueType {
    };

    template <class ContainerAllocator>
    struct MD5Sum<::mission_parse::formationwithtask_<ContainerAllocator>> {
        static const char* value()
        {
            return "aaa59390d3ef94c167bb31435c11ca0a";
        }

        static const char* value(const ::mission_parse::formationwithtask_<ContainerAllocator>&) { return value(); }
        static const uint64_t static_value1 = 0xaaa59390d3ef94c1ULL;
        static const uint64_t static_value2 = 0x67bb31435c11ca0aULL;
    };

    template <class ContainerAllocator>
    struct DataType<::mission_parse::formationwithtask_<ContainerAllocator>> {
        static const char* value()
        {
            return "mission_parse/formationwithtask";
        }

        static const char* value(const ::mission_parse::formationwithtask_<ContainerAllocator>&) { return value(); }
    };

    template <class ContainerAllocator>
    struct Definition<::mission_parse::formationwithtask_<ContainerAllocator>> {
        static const char* value()
        {
            return "Header header\n"
                   "geometry_msgs/Pose goal\n"
                   "int16 leader_id\n"
                   "int16 follower_num\n"
                   "int16[] follower_id\n"
                   "float32[] distance\n"
                   "float32[] angle\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: std_msgs/Header\n"
                   "# Standard metadata for higher-level stamped data types.\n"
                   "# This is generally used to communicate timestamped data \n"
                   "# in a particular coordinate frame.\n"
                   "# \n"
                   "# sequence ID: consecutively increasing ID \n"
                   "uint32 seq\n"
                   "#Two-integer timestamp that is expressed as:\n"
                   "# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
                   "# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
                   "# time-handling sugar is provided by the client library\n"
                   "time stamp\n"
                   "#Frame this data is associated with\n"
                   "string frame_id\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Pose\n"
                   "# A representation of pose in free space, composed of position and orientation. \n"
                   "Point position\n"
                   "Quaternion orientation\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Point\n"
                   "# This contains the position of a point in free space\n"
                   "float64 x\n"
                   "float64 y\n"
                   "float64 z\n"
                   "\n"
                   "================================================================================\n"
                   "MSG: geometry_msgs/Quaternion\n"
                   "# This represents an orientation in free space in quaternion form.\n"
                   "\n"
                   "float64 x\n"
                   "float64 y\n"
                   "float64 z\n"
                   "float64 w\n";
        }

        static const char* value(const ::mission_parse::formationwithtask_<ContainerAllocator>&) { return value(); }
    };

} // namespace message_traits
} // namespace ros

namespace ros {
namespace serialization {

    template <class ContainerAllocator>
    struct Serializer<::mission_parse::formationwithtask_<ContainerAllocator>> {
        template <typename Stream, typename T>
        inline static void allInOne(Stream& stream, T m)
        {
            stream.next(m.header);
            stream.next(m.goal);
            stream.next(m.leader_id);
            stream.next(m.follower_num);
            stream.next(m.follower_id);
            stream.next(m.distance);
            stream.next(m.angle);
        }

        ROS_DECLARE_ALLINONE_SERIALIZER
    }; // struct formationwithtask_

} // namespace serialization
} // namespace ros

namespace ros {
namespace message_operations {

    template <class ContainerAllocator>
    struct Printer<::mission_parse::formationwithtask_<ContainerAllocator>> {
        template <typename Stream>
        static void stream(Stream& s, const std::string& indent, const ::mission_parse::formationwithtask_<ContainerAllocator>& v)
        {
            s << indent << "header: ";
            s << std::endl;
            Printer<::std_msgs::Header_<ContainerAllocator>>::stream(s, indent + "  ", v.header);
            s << indent << "goal: ";
            s << std::endl;
            Printer<::geometry_msgs::Pose_<ContainerAllocator>>::stream(s, indent + "  ", v.goal);
            s << indent << "leader_id: ";
            Printer<int16_t>::stream(s, indent + "  ", v.leader_id);
            s << indent << "follower_num: ";
            Printer<int16_t>::stream(s, indent + "  ", v.follower_num);
            s << indent << "follower_id[]" << std::endl;
            for (size_t i = 0; i < v.follower_id.size(); ++i) {
                s << indent << "  follower_id[" << i << "]: ";
                Printer<int16_t>::stream(s, indent + "  ", v.follower_id[i]);
            }
            s << indent << "distance[]" << std::endl;
            for (size_t i = 0; i < v.distance.size(); ++i) {
                s << indent << "  distance[" << i << "]: ";
                Printer<float>::stream(s, indent + "  ", v.distance[i]);
            }
            s << indent << "angle[]" << std::endl;
            for (size_t i = 0; i < v.angle.size(); ++i) {
                s << indent << "  angle[" << i << "]: ";
                Printer<float>::stream(s, indent + "  ", v.angle[i]);
            }
        }
    };

} // namespace message_operations
} // namespace ros

#endif // MISSION_PARSE_MESSAGE_FORMATIONWITHTASK_H
